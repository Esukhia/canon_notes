from pathlib import Path
from diff_match_patch import diff_match_patch
import re


def is_derge_page_diff(diff):
    op, text = diff
    return '[' in text and ']' in text and op == 1


def match_derge_page(text):
    regex = r'(\\\[.*?\\\])'
    match = re.findall(regex, text)
    return match[0] if match else None


def clean_patches(orig_patches, is_needed_diff, find_needed):
    """
    Selects and cleans a given patch list using functions given as arguments
    Intended for patches generated by Google's diff_match_patch module.

    :param orig_patches: original set of patches
    :type orig_patches: patch objects created with DMP.patch_make(str, str)
    :param is_needed_diff: test to see if a diff contains a wanted modification
    :type is_needed_diff: funct returning a boolean
    :param find_needed: finds the parts of the diff that are to keep
    :type find_needed: funct returning the replacement str
    :return: filtered set of patches that only contain the needed modifications
    """
    new_patches = []
    for patch in orig_patches:
        keep = False
        new_diffs = []
        for diff in patch.diffs:

            # find diff to modify
            if is_needed_diff(diff):
                op, text = diff
                needed = find_needed(text)
                if needed:
                    new_diffs.append((op, needed))
                    keep = True

            # Important: keep the diffs with no modification used as context
            # (used by DMP to calculate the correct patching location)
            elif diff[0] == 0:
                new_diffs.append(diff)

        # select only relevant patches
        if keep:
            patch.diffs = new_diffs  # replace the old diffs with the modified ones
            new_patches.append(patch)

    return new_patches


def format_page_ref(string):
    replacement = [('1', '༡'), ('2', '༢'), ('3', '༣'), ('4', '༤'), ('5', '༥'),
                   ('6', '༦'), ('7', '༧'), ('8', '༨'), ('9', '༩'), ('0', '༠'),
                   ('a', 'ན'), ('b', 'བ')]
    chunks = re.split(r'(\[.*?\])', string)
    i = 0
    while i < len(chunks):
        if '[' in chunks[i]:
            c = chunks[i].replace('[', '\[').replace(']', '\]')
            for x, y in replacement:
                c = c.replace(x, y)
            chunks[i] = c
        i += 1

    return ''.join(chunks)


def insert_derge_pages(base, modified):
    # generate patches
    with_page = Path(modified).read_text()
    with_page = format_page_ref(with_page)  # apply formatting to derge page reference
    base = Path(base).read_text()
    patches = dmp.patch_make(base, with_page)

    page_patches = clean_patches(patches, is_derge_page_diff, match_derge_page)
    page_inserted, res = dmp.patch_apply(page_patches, base)
    log = ''
    for num, r in enumerate(res):
        if not r:
            log += f'{num} not applied:\n\t{page_patches[num]}\n'
    return page_inserted, log


def process(base_dir, mod_dir, out_dir):
    base_dir = Path(base_dir)
    mod_dir = Path(mod_dir)
    out_dir = Path(out_dir)

    for base in base_dir.glob('*.txt'):
        toh = base.stem.split('_')[0]
        mod = mod_dir / f'{toh}.txt'
        if mod.is_file():
            out, log = insert_derge_pages(base, mod)
            Path(out_dir / f'{toh}_final.txt').write_text(out)
        else:
            print(mod)


if __name__ == '__main__':
    dmp = diff_match_patch()

    base_dir = 'output/1-3-post_seg/'
    mod_dir = 'output/3a-1-page_refs/'
    out_dir = 'output/3-3-final/'
    process(base_dir, mod_dir, out_dir)
